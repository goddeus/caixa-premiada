const { PrismaClient } = require('@prisma/client');
const addictiveRTPService = require('./addictiveRTPService');
const prisma = new PrismaClient();

/**
 * SISTEMA DE SORTEIO MANIPULATIVO
 * 
 * Este servi√ßo implementa t√©cnicas avan√ßadas de manipula√ß√£o psicol√≥gica:
 * - RTP din√¢mico baseado no comportamento
 * - Near miss (quase vit√≥rias)
 * - Loss chasing (persegui√ß√£o de perdas)
 * - Sunk cost fallacy (fal√°cia do custo afundado)
 * - Variable ratio reinforcement (refor√ßo de raz√£o vari√°vel)
 */
class ManipulativeDrawService {

  /**
   * Sorteio principal com manipula√ß√£o psicol√≥gica
   */
  async performManipulativeDraw(caseId, userId) {
    try {
      console.log(`üß† Iniciando sorteio manipulativo para usu√°rio ${userId}`);
      
      // 1. ANALISAR COMPORTAMENTO DO USU√ÅRIO
      const behaviorProfile = await addictiveRTPService.analyzeUserBehavior(userId);
      console.log('üìä Perfil comportamental:', behaviorProfile);
      
      // 2. CALCULAR RTP DIN√ÇMICO
      const rtpConfig = await addictiveRTPService.calculateDynamicRTP(userId, caseId, behaviorProfile);
      console.log('üéØ Configura√ß√£o RTP:', rtpConfig);
      
      // 3. GERAR PR√äMIOS MANIPULATIVOS
      const manipulativePrizes = await addictiveRTPService.generateAddictivePrizes(caseId, userId, rtpConfig);
      console.log('üé≤ Pr√™mios gerados:', manipulativePrizes);
      
      // 4. REALIZAR SORTEIO PONDERADO
      const selectedPrize = this.performWeightedDraw(manipulativePrizes);
      console.log('üéÅ Pr√™mio selecionado:', selectedPrize);
      
      // 5. APLICAR NEAR MISS SE NECESS√ÅRIO
      const finalPrize = await addictiveRTPService.generateNearMiss(userId, caseId, selectedPrize);
      console.log('üéØ Pr√™mio final (com near miss):', finalPrize);
      
      // 6. REGISTRAR COMPORTAMENTO
      await addictiveRTPService.recordBehavior(userId, caseId, finalPrize, rtpConfig);
      
      // 7. APLICAR T√âCNICAS PSICOL√ìGICAS ADICIONAIS
      const enhancedPrize = await this.applyPsychologicalTechniques(userId, finalPrize, behaviorProfile);
      
      return {
        success: true,
        prize: enhancedPrize,
        rtpUsed: rtpConfig.rtp,
        strategy: rtpConfig.strategy,
        behaviorProfile: behaviorProfile,
        isManipulative: true
      };
      
    } catch (error) {
      console.error('‚ùå Erro no sorteio manipulativo:', error);
      return {
        success: false,
        error: 'Erro no sistema de sorteio',
        prize: null
      };
    }
  }

  /**
   * Realiza sorteio ponderado baseado nas probabilidades
   */
  performWeightedDraw(prizes) {
    const totalProbability = prizes.reduce((sum, prize) => sum + prize.probabilidade, 0);
    const random = Math.random() * totalProbability;
    
    let currentProbability = 0;
    for (const prize of prizes) {
      currentProbability += prize.probabilidade;
      if (random <= currentProbability) {
        return prize;
      }
    }
    
    // Fallback para o √∫ltimo pr√™mio
    return prizes[prizes.length - 1];
  }

  /**
   * Aplica t√©cnicas psicol√≥gicas adicionais
   */
  async applyPsychologicalTechniques(userId, prize, behaviorProfile) {
    let enhancedPrize = { ...prize };
    
    // 1. T√âCNICA: Sunk Cost Fallacy
    if (behaviorProfile.totalSpent > 100 && prize.valor === 0) {
      enhancedPrize.psychologicalMessage = `Voc√™ j√° investiu R$ ${behaviorProfile.totalSpent.toFixed(2)}! N√£o desista agora!`;
    }
    
    // 2. T√âCNICA: Loss Chasing
    if (behaviorProfile.isLossChasing && prize.valor === 0) {
      enhancedPrize.psychologicalMessage = `Voc√™ est√° com R$ ${behaviorProfile.netLoss.toFixed(2)} de preju√≠zo. Recupere agora!`;
    }
    
    // 3. T√âCNICA: Variable Ratio Reinforcement
    if (behaviorProfile.gamesLast24h > 5 && prize.valor > 0) {
      enhancedPrize.psychologicalMessage = `Parab√©ns! Voc√™ merece essa vit√≥ria ap√≥s ${behaviorProfile.gamesLast24h} tentativas!`;
    }
    
    // 4. T√âCNICA: FOMO (Fear of Missing Out)
    if (behaviorProfile.isAboutToQuit && prize.valor > 0) {
      enhancedPrize.psychologicalMessage = `Que sorte! Voc√™ quase perdeu essa oportunidade!`;
    }
    
    // 5. T√âCNICA: Social Proof
    if (prize.valor > 10) {
      enhancedPrize.psychologicalMessage = `Incr√≠vel! Apenas 1% dos jogadores ganham isso!`;
    }
    
    return enhancedPrize;
  }

  /**
   * Calcula quando dar um pr√™mio grande para reter o usu√°rio
   */
  async shouldGiveRetentionPrize(userId) {
    try {
      const behaviorProfile = await addictiveRTPService.analyzeUserBehavior(userId);
      
      // Crit√©rios para dar pr√™mio de reten√ß√£o:
      // 1. Usu√°rio perdeu muito dinheiro
      // 2. Usu√°rio est√° prestes a desistir
      // 3. Usu√°rio n√£o ganhou nada nas √∫ltimas 10 tentativas
      
      const shouldGive = (
        behaviorProfile.netLoss > 50 && // Perdeu mais de R$ 50
        behaviorProfile.isAboutToQuit && // Est√° prestes a desistir
        behaviorProfile.gamesLast24h < 3 // N√£o est√° jogando muito hoje
      );
      
      console.log(`üéØ Deve dar pr√™mio de reten√ß√£o para ${userId}: ${shouldGive}`);
      return shouldGive;
      
    } catch (error) {
      console.error('Erro ao verificar pr√™mio de reten√ß√£o:', error);
      return false;
    }
  }

  /**
   * Gera pr√™mio de reten√ß√£o (grande pr√™mio para n√£o perder o usu√°rio) - limitado pelo caixa total
   */
  async generateRetentionPrize(caseId, userId) {
    try {
      const caseData = await prisma.case.findUnique({
        where: { id: caseId }
      });
      
      if (!caseData) return null;
      
      // VERIFICAR CAIXA TOTAL DA PLATAFORMA
      const cashFlowService = require('./cashFlowService');
      const caixaData = await cashFlowService.calcularCaixaLiquido();
      const caixaTotal = caixaData.caixaLiquido;
      
      console.log(`üí∞ [RETENTION PRIZE] Caixa total: R$ ${caixaTotal.toFixed(2)}`);
      
      // Se caixa total for insuficiente, n√£o dar pr√™mio de reten√ß√£o
      if (caixaTotal <= 0) {
        console.log(`‚ö†Ô∏è [RETENTION PRIZE] Caixa total insuficiente. N√£o dando pr√™mio de reten√ß√£o.`);
        return {
          nome: 'Sistema em Manuten√ß√£o',
          valor: 0,
          probabilidade: 1.0,
          tipo: 'motivacional',
          psychologicalMessage: 'Sistema temporariamente indispon√≠vel. Tente novamente mais tarde.'
        };
      }
      
      const casePrice = parseFloat(caseData.preco);
      
      // Pr√™mio de reten√ß√£o: m√°ximo 5% do caixa total ou 10x o valor da caixa (o menor)
      const maxRetentionValue = Math.min(caixaTotal * 0.05, casePrice * 10);
      const retentionValue = Math.min(maxRetentionValue, casePrice * (5 + Math.random() * 5));
      
      console.log(`üéØ [RETENTION PRIZE] Pr√™mio de reten√ß√£o: R$ ${retentionValue.toFixed(2)} (M√°ximo: R$ ${maxRetentionValue.toFixed(2)})`);
      
      return {
        nome: 'Pr√™mio de Reten√ß√£o',
        valor: retentionValue,
        probabilidade: 1.0, // 100% de chance (manipulado)
        tipo: 'retention',
        psychologicalMessage: 'Parab√©ns! Voc√™ merece essa vit√≥ria especial!'
      };
      
    } catch (error) {
      console.error('Erro ao gerar pr√™mio de reten√ß√£o:', error);
      return null;
    }
  }

  /**
   * Implementa sistema de "hot streak" (sequ√™ncia de vit√≥rias)
   */
  async checkHotStreak(userId) {
    try {
      const recentTransactions = await prisma.transaction.findMany({
        where: {
          user_id: userId,
          tipo: 'premio',
          created_at: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // √öltimas 24h
          }
        },
        orderBy: { created_at: 'desc' },
        take: 5
      });
      
      // Se ganhou nas √∫ltimas 3 tentativas, est√° em "hot streak"
      const isHotStreak = recentTransactions.length >= 3;
      
      if (isHotStreak) {
        console.log(`üî• Usu√°rio ${userId} est√° em hot streak!`);
        return {
          isHotStreak: true,
          streakCount: recentTransactions.length,
          shouldReduceRTP: true // Reduzir RTP para quebrar a sequ√™ncia
        };
      }
      
      return { isHotStreak: false, streakCount: 0, shouldReduceRTP: false };
      
    } catch (error) {
      console.error('Erro ao verificar hot streak:', error);
      return { isHotStreak: false, streakCount: 0, shouldReduceRTP: false };
    }
  }

  /**
   * Implementa sistema de "cold streak" (sequ√™ncia de perdas)
   */
  async checkColdStreak(userId) {
    try {
      const recentTransactions = await prisma.transaction.findMany({
        where: {
          user_id: userId,
          tipo: 'abertura_caixa',
          created_at: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // √öltimas 24h
          }
        },
        orderBy: { created_at: 'desc' },
        take: 10
      });
      
      // Se perdeu nas √∫ltimas 8 tentativas, est√° em "cold streak"
      const isColdStreak = recentTransactions.length >= 8;
      
      if (isColdStreak) {
        console.log(`‚ùÑÔ∏è Usu√°rio ${userId} est√° em cold streak!`);
        return {
          isColdStreak: true,
          streakCount: recentTransactions.length,
          shouldGivePrize: true // Dar pr√™mio para quebrar a sequ√™ncia
        };
      }
      
      return { isColdStreak: false, streakCount: 0, shouldGivePrize: false };
      
    } catch (error) {
      console.error('Erro ao verificar cold streak:', error);
      return { isColdStreak: false, streakCount: 0, shouldGivePrize: false };
    }
  }

  /**
   * Calcula o momento ideal para dar um pr√™mio grande
   */
  async calculateOptimalPrizeTiming(userId) {
    try {
      const behaviorProfile = await addictiveRTPService.analyzeUserBehavior(userId);
      const hotStreak = await this.checkHotStreak(userId);
      const coldStreak = await this.checkColdStreak(userId);
      
      // Crit√©rios para dar pr√™mio grande:
      // 1. Usu√°rio perdeu muito dinheiro
      // 2. Usu√°rio est√° em cold streak
      // 3. Usu√°rio n√£o est√° em hot streak
      // 4. Usu√°rio est√° prestes a desistir
      
      const shouldGiveBigPrize = (
        behaviorProfile.netLoss > 100 && // Perdeu mais de R$ 100
        coldStreak.isColdStreak && // Est√° em cold streak
        !hotStreak.isHotStreak && // N√£o est√° em hot streak
        behaviorProfile.isAboutToQuit // Est√° prestes a desistir
      );
      
      console.log(`üéØ Momento ideal para pr√™mio grande (${userId}): ${shouldGiveBigPrize}`);
      
      return {
        shouldGiveBigPrize,
        reason: shouldGiveBigPrize ? 'Retention strategy' : 'Continue extraction',
        behaviorProfile,
        hotStreak,
        coldStreak
      };
      
    } catch (error) {
      console.error('Erro ao calcular timing de pr√™mio:', error);
      return { shouldGiveBigPrize: false, reason: 'Error' };
    }
  }
}

module.exports = new ManipulativeDrawService();
